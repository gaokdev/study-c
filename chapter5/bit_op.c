// 비트 이동 연산자 예제

#include <stdio.h>

int main()
{
    // %08X는 대문자로 16진수를 출력하는데 필드폭은 8이고 빈 곳은 0으로 채우라는 의미
    printf("AND : %08X\n", 0x9 & 0xA); // 0x9 : 1001, 0xA : 1010을 비트 AND 연산을 하면은 1000. 16진수로 바꾸면 00000008이 된다
    printf("OR : %08X\n", 0x9 | 0xA); // 0x9 : 1001, 0xA : 1010을 비트 OR 연산을 하면은 1011. 16진수로 바꾸면 0000000B이 된다
    printf("XOR : %08X\n", 0x9 ^ 0xA); // 0x9 : 1001, 0xA : 1010을 비트 XOR 연산을 하면은 0011. 16진수로 바꾸면 00000003이 된다
    printf("NOT : %08X\n", ~0x9); // 0x9 : 1001을 비트 NOT 연산을 하면은 0110, 그런데 4바이트 int에서 모든 0이 1로 바뀌므로 16진수로 바꾸면은 FFFFFFF6
    printf("NOT : %d\n", ~0x9); // ~0x9를 십진수로 출력
    printf("<< : %08X\n", 0x4 << 1); // 왼쪽 비트 이동을 하면은 1비트를 움직일 때마다 2를 곱하는 것과 같다
    printf(">> : %08X\n", 0x4 >> 1); // 오른쪽 비트 이동을 하면은 1비트를 움직일 때마다 2를 나누는 것과 같다

    
    return 0;
}

/*printf()에서 정수는 기본적으로 int 타입 : 4바이트 : 32비트로 처리된다

printf("NOT : %08X\n", ~0x9);
를 했을 경우에 
0x9 : 0000 0000 / 0000 0000 / 0000 0000 / 0000 1001이 된다
~0x9로 NOT 연산을 하면은
1111 1111 / 1111 1111 / 1111 1111 / 1111 0110이 되므로
16진수로 바꾸면은
FFFFFFF6이 되는것이다

그리고 FFFFFFF6이 십진수로 어떤 수냐 라고했을떄
MSB가 1이니 음수이므로 2의 보수 구하는 과정을 수행한다

1111 1111 / 1111 1111 / 1111 1111 / 1111 0110의 비트 반전
0000 0000 / 0000 0000 / 0000 0000 / 0000 1001의 +1
0000 0000 / 0000 0000 / 0000 0000 / 0000 1010은 16진수로 0xA, 십진수로 10

그래서 16진수 FFFFFFF6은 십진수 -10이다*/